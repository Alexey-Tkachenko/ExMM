# Начало работы

Для работы необходим компилятор, поддерживающий как минимум стандарт C++11.

## Подключение

Библиотека подключается с помощью заголовочного файла "exmm.hpp", который размещается в каталоге `src/` проекта. Он может быть подключен либо как submodule системы контроля версий, либо с помощью Conan-пакета /todo/[вписать название]

## Определение контроллера

### Определение класса контроллера

Для создания собственного имитатора контроллера необходимо определить класс, который будет унаследован от шаблонного типа `ExMM::ControllerBase<...>`.
Первым шаблонным аргументом передаётся тип перехватываемого обращения: `ExMM::HookTypes::ReadWrite`, `ExMM::HookTypes::Write`, `ExMM::HookTypes::Read` либо `ExMM::HookTypes::None`.
Второй параметр опциональный, определяет тип структуры регистрового файла. Он должен быть POD-типом. Если он не определён, тип регистрового файла считается `void*`, и в этом случае будут недоступны многие описанные ниже возможности.

### Определение регистрового файла

Регистровый файл описывается структурой, которая может содержать как простые типы произвольного размера, так и агрегатные типы - массивы и вложенные структуры. Для работы с каждым из них предусмотрены средства для оценки доступа.

### Тестовый пример. Итерация 1.

Для дальнейшего описания воспользуемся следующим примером:

```c++
struct Registers
{
    uint32_t Simple1;
    uint32_t Simple2;
    struct
    {
        uint16_t A;
        uint16_t B;
    } Nested;
    uint32_t Array[4];
    struct
    {
        uint32_t Low;
        uint32_t High;
    } NestedArray[8];
};

class TestController : public ExMM::ControllerBase<ExMM::HookTypes::ReadWrite, Registers>
{

};

```

С точки зрения клиентского кода у объекта контроллера необходимо получить указатель на регистровый файл:
```C++
void UserCode()
{
    const TestController controller;
    volatile Registers* registers = controller.GetIoArea();

    //...
}
```
Дальнейшая работа в пользовательском коде ведётся исключительо через указатель `registers`.

Если предполагается нетипизированный регистровый файл, конструктор базового типа контроллера требует размер регистрового файла в байтах.

### Адаптация кода драйвера

Обычно код драйвера полагается на определения базовых адресов в заголовочных файлах, генерируемых средствами разработки. Для того, чтобы использовать данную библиотеку, необходимо допустить возможность конфигурирования базового адреса регистрового файла на этапе выполнения. Это можно сделать различными способами: передачей указателя в класс с высокоуровневой логикой драйвера, использующего регистровый файл; объявлением глобальной переменной и связывание её со значением во время выполнения; созданием функции конфигурирования базового адреса и т.п. При разработке драйвера на C++ рекомендованным является первый способ, при разработке на Си - второй.

### Перехват обращения к полям
Для перехвата обращения к полям необходимо перекрыть виртуальные методы `HookWrite` и `HookRead` для записи и чтения соответственно. Они имеют одинаковые сигнатуры и принимают указатель на регистровый файл и запрошенное смещение:
```C++
class TestController : public ExMM::ControllerBase<ExMM::HookTypes::ReadWrite, Registers>
{
    void HookRead(Registers* data, size_t offset) override
    {}

    void HookWrite(Registers* data, size_t offset) override
    {} 
};
```

